#include <mpc_planner/planner.h>

#include <mpc_planner/experiment_util.h>

/** @note: Autogenerated */
#include <mpc_planner_modules/modules.h>

#include <mpc_planner_types/realtime_data.h>
#include <mpc_planner_solver/solver_interface.h>

#include <mpc_planner_util/load_yaml.hpp>
#include <mpc_planner_util/parameters.h>
#include <mpc_planner_util/data_visualization.h>

#include <ros_tools/profiling.h>
#include <ros_tools/logging.h>
#include <ros_tools/visuals.h>
#include <ros_tools/data_saver.h>

namespace MPCPlanner
{

    Planner::Planner()
    {
        // Initialize the solver
        _solver = std::make_shared<Solver>();
        _solver->reset();

        initializeModules(_modules, _solver);

        _experiment_util = std::make_shared<ExperimentUtil>();

        _startup_timer = std::make_unique<RosTools::Timer>(1.0); // Give some time to receive data
    }

    // Given real-time data, solve the MPC problem
    PlannerOutput Planner::solveMPC(State &state, RealTimeData &data)
    {
        LOG_MARK("Planner::solveMPC");
        bool was_feasible = _output.success;
        _output = PlannerOutput(_solver->dt, _solver->N);

        _module_data = ModuleData(); // Reset module data

        // Check if all modules have enough data
        _is_data_ready = true;
        std::string missing_data;
        for (auto &module : _modules)
            _is_data_ready = _is_data_ready & module->isDataReady(data, missing_data);

        if (!_is_data_ready)
        {
            if (_startup_timer->hasFinished())
                LOG_WARN_THROTTLE(3000, "Data is not ready, missing " + missing_data + "\b");

            _output.success = false;
            return _output;
        }
        else if (_was_reset)
        {
            _experiment_util->setStartExperiment();
            _was_reset = false;
        }

        LOG_MARK("Data checked");

        int exit_flag;
        {
            PROFILE_SCOPE("Planning");

            auto &planning_benchmarker = BENCHMARKERS.getBenchmarker("planning");
            if (planning_benchmarker.isRunning())
                planning_benchmarker.cancel();

            planning_benchmarker.start();

            // Set the initial guess
            bool shift_forward = CONFIG["shift_previous_solution_forward"].as<bool>() &&
                                 CONFIG["enable_output"].as<bool>();
            if (was_feasible)
                _solver->initializeWarmstart(state, shift_forward);
            else
            {
                // _solver->initializeWithState(state);
                _solver->initializeWithBraking(state);
            }

            _solver->setXinit(state); // Set the initial state

            // Update all modules
            {
                LOG_MARK("Updating modules");
                PROFILE_SCOPE("Update");

                for (auto &module : _modules)
                    module->update(state, data, _module_data);
            }

            {
                LOG_MARK("Setting parameters");
                PROFILE_SCOPE("SetParameters");
                for (int k = 0; k < _solver->N; k++)
                {
                    for (auto &module : _modules)
                    {
                        module->setParameters(data, _module_data, k);
                    }
                }
            }

            _warmstart = Trajectory();
            for (int k = 0; k < _solver->N; k++)
                _warmstart.add(_solver->getEgoPrediction(k, "x"), _solver->getEgoPrediction(k, "y"));

            _solver->loadWarmstart();

            std::chrono::duration<double> used_time = std::chrono::system_clock::now() - data.planning_start_time;
            _solver->_params.solver_timeout = 1. / CONFIG["control_frequency"].as<double>() - used_time.count() - 0.006;

            // Solve MPC
            LOG_MARK("Solve optimization");
            {
                PROFILE_SCOPE("Optimization");
                BENCHMARKERS.getBenchmarker("optimization").start();
                exit_flag = EXIT_CODE_NOT_OPTIMIZED_YET;
                for (auto &module : _modules)
                {
                    exit_flag = module->optimize(state, data, _module_data);
                    if (exit_flag != EXIT_CODE_NOT_OPTIMIZED_YET)
                        break;
                }
                if (exit_flag == EXIT_CODE_NOT_OPTIMIZED_YET)
                    exit_flag = _solver->solve();
                BENCHMARKERS.getBenchmarker("optimization").stop();
            }

            planning_benchmarker.stop();
        }

        if (exit_flag != 1)
        {
            _output.success = false;
            LOG_WARN_THROTTLE(500, "MPC failed: " + _solver->explainExitFlag(exit_flag));

            return _output;
        }

        _output.success = true;
        for (int k = 1; k < _solver->N; k++)
            _output.trajectory.add(_solver->getOutput(k, "x"), _solver->getOutput(k, "y"));

        if (_output.success && CONFIG["debug_limits"].as<bool>())
            _solver->printIfBoundLimited();

        LOG_MARK("Planner::solveMPC done");

        return _output;
    }

    double Planner::getSolution(int k, std::string &&var_name) const
    {
        return _solver->getOutput(k, std::forward<std::string>(var_name));
    }

    RosTools::DataSaver &Planner::getDataSaver() const
    {
        return _experiment_util->getDataSaver();
    }

    void Planner::onDataReceived(RealTimeData &data, std::string &&data_name)
    {
        for (auto &module : _modules)
            module->onDataReceived(data, std::forward<std::string>(data_name));
    }

    void Planner::visualize(const State &state, const RealTimeData &data)
    {
        PROFILE_SCOPE("Planner::Visualize");
        LOG_MARK("Planner::visualize");
        (void)state;

        for (auto &module : _modules)
            module->visualize(data, _module_data);

        visualizeTrajectory(_output.trajectory, "planned_trajectory", true, 0.2);

        if (CONFIG["debug_visuals"].as<bool>())
            visualizeTrajectory(_warmstart, "warmstart_trajectory", true, 0.2);

        visualizeObstacles(data.dynamic_obstacles, "obstacles", true, 1.0);
        visualizeObstaclePredictions(data.dynamic_obstacles, "obstacle_predictions", true);
        visualizeRobotArea(state.getPos(), state.get("psi"), data.robot_area, "robot_area", true);

        std::vector<double> angles;
        for (int k = 1; k < _solver->N; k++)
            angles.emplace_back(_solver->getOutput(k, "psi"));

        visualizeRectangularRobotArea(state.getPos(), state.get("psi"),
                                      CONFIG["robot"]["length"].as<double>(), CONFIG["robot"]["width"].as<double>(),
                                      "robot_rect_area", true);

        visualizeRobotAreaTrajectory(_output.trajectory, angles, data.robot_area, "robot_area_trajectory", true, 0.1);
        LOG_MARK("Planner::visualize Done");
    }

    void Planner::saveData(State &state, RealTimeData &data)
    {
        if (!_is_data_ready)
            return;

        auto &data_saver = _experiment_util->getDataSaver();

        // Save planning data
        double planning_time = BENCHMARKERS.getBenchmarker("planning").getLast();
        data_saver.AddData("runtime_control_loop", planning_time);
        if (planning_time > 1. / CONFIG["control_frequency"].as<double>())
            LOG_WARN("Planning took too long: " << planning_time << " ms");
        data_saver.AddData("runtime_optimization", BENCHMARKERS.getBenchmarker("optimization").getLast());

        if (!_output.success)
            data_saver.AddData("status", 3.); // 3 and 2 for backward compatilibity
        else
            data_saver.AddData("status", 2.);

        for (auto &module : _modules)
            module->saveData(data_saver);

        _experiment_util->update(state, _solver, data);
    }

    void Planner::reset(State &state, RealTimeData &data, bool success)
    {
        if (CONFIG["recording"]["enable"].as<bool>())
            _experiment_util->onTaskComplete(success); // Save data

        _solver->reset(); // Reset the solver

        for (auto &module : _modules) // Reset modules
            module->reset();

        state = State(); // Reset the state
        data.reset();    // Reset the data
        _was_reset = true;
        _startup_timer->start();
    }

    bool Planner::isObjectiveReached(const State &state, const RealTimeData &data) const
    {
        bool objective_reached = true;
        for (auto &module : _modules)
            objective_reached = objective_reached && module->isObjectiveReached(state, data);
        return objective_reached;
    }
}